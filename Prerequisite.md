<div dir="rtl">
<h2>Cryptography</h2>
رمزنگاری چیه؟

رمزنگاری یا Cryptography همون کاریه که باعث میشه وقتی یه اطلاعاتی رو می‌فرستیم، هیچ‌کس نتونه اونو بخونه یا دستکاری کنه. یعنی میایم داده‌هامون رو با یه سری فرمول ریاضی (الگوریتم) تبدیل می‌کنیم به یه چیزی که خونده نمی‌شه، مگر اینکه یه کلید خاص داشته باشیم. این کلید لازمه تا بتونیم داده‌هارو رمز کنیم (encrypt) و بعداً هم با همون کلید یا یه کلید دیگه رمزگشایی (decrypt) کنیم.

دو نوع رمزنگاری داریم:

رمزنگاری متقارن (Symmetric):
تو این روش، فرستنده و گیرنده هر دو از همون یه دونه کلید واسه رمز کردن و رمزگشایی استفاده می‌کنن. مثلاً یه الگوریتم معروف تو این مدل AES هست.

رمزنگاری نامتقارن (Asymmetric):
اینجا به جای یه کلید، از دو تا کلید استفاده می‌شه. یکی برای رمز کردن (encrypt) و یکی دیگه برای باز کردن (decrypt) داده‌ها. مثلاً تو الگوریتم RSA ما یه کلید عمومی (Public key) و یه کلید خصوصی (Private key) داریم.

اگه یه چیزی رو با کلید خصوصی (Private key) رمز کنیم، همه می‌تونن با کلید عمومی (Public key) ما اونو باز کنن، چون کلید عمومی برای همه‌ست.
ولی اگه یکی بخواد فقط خودمون یه پیغام رو ببینیم، میاد با کلید عمومی ما (Public key) اونو رمز می‌کنه. حالا فقط کلید خصوصی خودمونه که می‌تونه اون پیغام رو باز کنه، و این کلید رو هم فقط ما داریم.
یه نکته مهم: وقتی می‌خوایم یه کلید انتخاب کنیم، مثلاً برای JWT، باید کلیدمون اونقدر قوی باشه که نشه با روش‌هایی مثل brute force اونو پیدا کرد. مثلاً نباید از رمزهایی استفاده کنیم که ساده‌ن یا تو لیست پسوردهای معروف تو گیت‌هاب پیدا می‌شن، چون اینجوری امنیت داده‌هامون به خطر می‌افته.

---
<h2>Encoding/Decoding</h2>
کدگذاری (Encoding) چیه؟

کدگذاری یه روشی هست که به کمکش، هر کاراکتری رو به یه شکل دیگه درمیاریم که برای کامپیوتر قابل فهم باشه. انواع مختلفی از کدگذاری داریم و هر کدوم برای یه هدف خاص طراحی شده.

چند نوع کدگذاری معروف:

ـASCII:
یه روش قدیمی برای تبدیل کاراکترها به اعداد که تو کامپیوتر و اینترنت استفاده میشه. توی ASCII، هر کاراکتر یه عدد مخصوص داره. بعضی از این کاراکترها قابل دیدن نیستن، مثلاً کلید Enter همون عدد 13 توی ASCII هست.

ـUnicode:
این یکی یه استاندارد جهانیه برای نمایش متن‌های مربوط به اکثر زبان‌های دنیا. UTF-8 هم معروف‌ترین روش کدگذاری یونیکد هست که بیشتر توی وب‌سایت‌ها استفاده میشه.

ـHexadecimal (Hex):
بهش base16 هم میگن، چون از 16 تا نماد استفاده می‌کنه: اعداد 0 تا 9 و حروف A تا F. مثلاً اگه بخوایم URL fsociety رو به Hex تبدیل کنیم، میشه:
66 73 6F 63 69 65 74 79

ـDecimal:
این همون اعدادیه که تو زندگی روزمره باهاشون سروکار داریم، یعنی بر پایه 10. مثل عدد 123.

ـURL encoding:
وقتی می‌خوایم یه سری کاراکترها رو توی URL یا آدرس اینترنتی قرار بدیم، باید به فرمتی تبدیلشون کنیم که برای اینترنت قابل خوندن باشه. مثلاً URL https://attacker.com/root وقتی URL encode بشه میشه:
https%3A%2F%2Fattacker.com%2Froot

ـBase64 encoding:
از این روش برای تبدیل داده‌ها به یه فرمت متنی استفاده می‌کنن که میشه اونو راحت ذخیره کرد یا فرستاد. از حروف انگلیسی، اعداد و چند تا کاراکتر خاص استفاده میشه. مثلاً fsociety توی Base64 میشه:
ZnNvY2lldHk=

ـHTML encoding:
توی HTML، بعضی کاراکترها مثل < و > یه معنی خاص دارن (برای باز و بسته کردن تگ‌ها). برای اینکه این کاراکترها به‌عنوان متن نمایش داده بشن و مرورگر اشتباه نکنه، باید اونا رو به فرمت خاصی تبدیل کنیم. مثلاً < میشه &lt; و > میشه &gt;. این کار کمک می‌کنه جلوی حملاتی مثل XSS و HTML Injection گرفته بشه.

نکته مهم:
کدگذاری قابل برگشته، یعنی هرکسی که کد شده رو ببینه می‌تونه دوباره به حالت اصلیش برگردونه. پس نباید اطلاعات حساس مثل رمز عبور رو فقط کدگذاری کنیم، چون مثل رمزنگاری به کلید نیاز نداره و راحت برمی‌گرده.

---
<h2>Hash</h2>


ـHash یعنی یه تابع یا فرایند که یه ورودی رو می‌گیره و یه خروجی مشخص تولید می‌کنه. این تبدیل یک طرفه است، یعنی از روی خروجی نمی‌تونی به ورودی اصلی برگردی. مثلاً اگه ورودی یه متن باشه، خروجی یه رشته طولانی از کاراکترها خواهد بود که بهش می‌گیم Hash.

الگوریتم‌های مختلفی برای این کار وجود داره، هر کدوم با ویژگی‌های خاص خودش مثل طول رشته خروجی. یکی از معروف‌ترین این الگوریتم‌ها MD5 هست.

کاربرد Hash
پسوردها یکی از جاهایی هستن که معمولاً با استفاده از Hash ذخیره می‌شن. چرا؟ چون اگر پسوردها به صورت متن ساده توی دیتابیس ذخیره بشن، اگه اطلاعات دیتابیس به دست یه هکر بیفته، هکر می‌تونه به راحتی پسوردها رو ببینه. ولی وقتی پسوردها به صورت Hash ذخیره بشن، به طور مستقیم نمی‌تونی پسورد رو پیدا کنی، اما کار برای هکرها هم سخت‌تر میشه.

چرا Hash به جای رمزنگاری؟
در رمزنگاری، اگه کلید رمزنگاری به دست بیفته، هکر می‌تونه به اطلاعات دسترسی پیدا کنه. اما در Hash، چون تبدیل یک طرفه است، مشکل اینه که هکر باید تلاش زیادی کنه تا بتونه پسورد اصلی رو پیدا کنه.

چطور هکرها Hash رو می‌شکنند؟
هکرها معمولاً از Rainbow Tables استفاده می‌کنن. این جداول شامل لیستی از پسوردها و Hash‌های مربوط به اونا هست. هکر می‌تونه یه Hash رو پیدا کنه و با استفاده از این جداول، ببینه که اون Hash به چه پسوردی مربوط میشه.

مثال:

فرض کن هکر یه Hash به این شکل پیدا کرده: 58b4e38f66bcdb546380845d6af27187. حالا میره به سایت‌هایی مثل CrackStation و این Hash رو جستجو می‌کنه. اگه این Hash در پایگاه داده این سایت وجود داشته باشه، ممکنه سایت نشون بده که پسورد مربوط به این Hash qwerty1234 هست.

نکته مهم:
گرچه Hash کردن پسوردها امنیت رو بیشتر می‌کنه، اما هیچ وقت نمی‌تونه به طور کامل جلوی حملات رو بگیره. هکرها همیشه راه‌هایی برای پیدا کردن پسوردها پیدا می‌کنن، پس بهتره از روش‌های امنیتی اضافی مثل استفاده از Salt و Hashing Algorithm های پیچیده‌تر استفاده کنی.

---
<h2>Reconnaissance</h2>
 
ریکان یا شناسایی چیه؟

ریکان به معنی جمع کردن اطلاعاته و دو نوع داره:

ریکان خارجی (External Recon)
ریکان داخلی (Internal Recon)


ریکان خارجی (External Recon):
این نوع شناسایی وقتی اتفاق می‌افته که هکر بخواد از بیرون شبکه یا سازمان، اطلاعات جمع کنه. یعنی بدون اینکه دسترسی مستقیم به سیستم‌های داخلی سازمان داشته باشه، فقط از طریق اینترنت و منابع عمومی شروع می‌کنه به جمع‌آوری اطلاعات. هدفش اینه که بفهمه سازمان چه دارایی‌های عمومی‌ای داره، مثل دامنه‌ها، وب‌سرورها، پورت‌های باز، سرویس‌های فعال، یا حتی اطلاعات حساسی مثل ایمیل‌های کارکنان.

روش‌ها و ابزارهای رایج:
پورت اسکنینگ (مثلاً با ابزار nmap)
دایرکتوری اسکنینگ (یا همون Fuzzing)
کشف ساب‌دامین‌ها
کشف DNS و اطلاعات شبکه


ریکان داخلی (Internal Recon):
اینجا ماجرا فرق می‌کنه. ریکان داخلی وقتی انجام میشه که هکر تونسته به شبکه داخلی سازمان نفوذ کنه. حالا ممکنه این نفوذ فیزیکی باشه یا از طریق حملاتی مثل RCE (Remote Code Execution). وقتی وارد شبکه شدن، هدفشون اینه که دستگاه‌ها و سرویس‌های داخلی رو بشناسن، معماری شبکه رو کشف کنن و ببینن چه پورت‌ها و سرویس‌هایی فعال هستن.

روش‌ها و ابزارهای رایج:
اسکن شبکه
ARP Scanning
Sniffing (دیده‌بانی ترافیک شبکه)
خلاصه:
ریکان خارجی (External): جمع‌آوری اطلاعات از منابع عمومی مثل اینترنت. هدف اینه که دارایی‌های متصل به اینترنت و زیرساخت‌های سازمان شناسایی بشه.
ریکان داخلی (Internal): وقتی هکر وارد شبکه داخلی سازمان شد، شروع می‌کنه به شناسایی دقیق‌تر زیرساخت‌ها، سرویس‌ها، دستگاه‌ها و کاربران.

---
<h2>Testing Methodologies</h2>

روش‌های تست:
دو نوع متد برای تست کردن داریم:

Active
Passive

متد Active:
یعنی وقتی مستقیم با سیستم یا وب‌سایت درگیر می‌شیم. مثلاً وقتی صفحه اصلی (index) یه وب‌سایت رو باز می‌کنیم، به طور مستقیم با سرور اون سایت ارتباط داریم و توی لاگ‌های سرور هم رد پایی ازمون می‌مونه (مثل access.log).

متد Passive:
اینجا برعکس حالت Active، ما مستقیم با سیستم یا سایت در ارتباط نیستیم. مثلاً ممکنه از ابزارهایی استفاده کنیم که بدون باز کردن مستقیم سایت، اطلاعاتی ازش بگیرن. تو این حالت، رد پایی ازمون توی لاگ‌های سرور نمی‌مونه.

---
<h2>URL Structure </h2>



```html
https://username:password@example.com:443/file.html?parameter=value#fragment
```
ساختار URL همون آدرسیه که توی مرورگر وارد می‌کنیم تا به یه صفحه وب برسیم. هر قسمت از این آدرس یه معنی خاص داره و مرورگر با خوندن این بخش‌ها می‌فهمه باید کجا بره و چیکار کنه.

بیایم این آدرس رو بررسی کنیم:

بخش‌های مختلف URL:

پروتکل (https):
این همون اول URL هست که مشخص می‌کنه از چه روشی می‌خوایم به سرور وصل بشیم. مثل HTTPS (که امنه) یا HTTP (که امن نیست).


اعتبارنامه‌ها (username@):
گاهی توی URL، قبل از @ یه چیزی می‌بینیم مثل username:password. اینجا اطلاعات ورود به سیستم قرار داره که مرورگر ازش برای ورود به سایت استفاده می‌کنه. البته خیلی رایج نیست که تو URL این اطلاعات رو بذارن، ولی اگه دیدی، بدون که اطلاعات ورود (credentials) اونجاست.


دامنه (example.com):
این همون اسم سایت یا سرور اصلیه که می‌خوایم بهش وصل بشیم. مثلاً توی اینجا، example.com همون سایته که قراره مرورگر ما بهش بره.


پورت (:443):
بعد از دامنه اگه یه عددی دیدی، اون پورت سروره. پورت 443 برای HTTPS استفاده می‌شه و اگه این عدد نباشه، مرورگر خودش می‌فهمه که از پورت پیش‌فرض (مثلاً 80 برای HTTP یا 443 برای HTTPS) استفاده کنه.


مسیر (file.html):
اینجا هم مسیریه که می‌خوایم تو سایت ببینیم. یعنی مرورگر می‌ره توی اون سایت و دنبال یه فایلی به اسم file.html می‌گرده. همون قسمتی از URL که بعد از / میاد، همون مسیره که می‌گه توی سرور به کدوم فایل یا صفحه بری.


پارامترها (?parameter=value):
بعد از ? یه سری اطلاعات اضافی میاد که مرورگر به سرور می‌فرسته. اینا می‌تونن هر چیزی باشن، مثل فیلتر کردن نتایج یا اطلاعاتی که باید به سرور بدیم. مثلاً parameter=value یعنی یه پارامتری به اسم parameter داریم که مقدارش value هست.


فرگمنت (#fragment):
این بخش بعد از # میاد و به مرورگر می‌گه که بره به یه جای خاص توی صفحه. مثلاً وقتی تو یه صفحه وب، یه قسمت خاص رو هایلایت می‌کنه یا به همون قسمت اسکرول می‌کنه.


خلاصه: URL شبیه یه نقشه‌ست که به مرورگر می‌گه از چه طریقی، به کدوم سایت بره، از کدوم پورت استفاده کنه، کدوم فایل رو باز کنه، چه اطلاعاتی رو بفرسته و توی کدوم قسمت از صفحه قرار بگیره.

---
<h2>HTTP Methods</h2>


ـ1. GET
کاری که انجام میده:
این متد برای گرفتن اطلاعات از سرور استفاده میشه. وقتی توی مرورگر آدرس یه سایت رو وارد می‌کنی یا روی یه لینک کلیک می‌کنی، مرورگر یه درخواست GET می‌فرسته تا اون صفحه رو برات بگیره.
در ضمن، GET می‌تونه اطلاعاتی رو هم به سرور بفرسته، اما این اطلاعات به‌جای اینکه توی بدنه (body) درخواست باشه، مستقیماً توی URL قرار می‌گیره. برای همین، اگه اطلاعات حساسی مثل پسورد داری، نباید از GET استفاده کنی.

مثال ساده:
وقتی یه صفحه از وب‌سایت رو می‌خوای ببینی، با GET درخواست می‌دی که اون صفحه رو برات بیاره. یا مثلاً وقتی می‌خوای توی یه فرم جستجو کنی، می‌تونی با GET پارامترهای جستجو رو توی URL بفرستی:
example.com/search?query=something

نکته مهم:

پارامترهایی که توی GET می‌فرستی، مستقیم توی URL قرار می‌گیرن، پس برای ارسال داده‌های حساس مناسب نیست.
همچنین GET فقط برای گرفتن اطلاعاته و نباید چیزی رو توی سرور تغییر بده.


ـ2. POST
کاری که انجام میده:
این متد برای ارسال اطلاعات به سرور استفاده می‌شه. وقتی توی فرم یه چیزی وارد می‌کنی و روی دکمه "ارسال" کلیک می‌کنی، درخواست POST می‌ره تا اطلاعات رو به سرور بفرسته.

مثال ساده:
وقتی یه فرم ثبت‌نام رو پر می‌کنی و می‌خوای اطلاعاتت رو بفرستی، POST استفاده می‌شه.

نکته مهم:
اطلاعاتی که ارسال می‌کنی توی URL نمایش داده نمی‌شه، بلکه به صورت پنهانی فرستاده می‌شه و معمولاً داده‌ها رو به سرور اضافه یا تغییر می‌ده.


ـ3. PUT
کاری که انجام میده:
این متد برای آپدیت یا جایگزینی اطلاعات روی سرور استفاده می‌شه. اگه بخوایم یه فایل یا اطلاعاتی رو توی سرور جایگزین کنیم، از PUT استفاده می‌کنیم.

مثال ساده:
فرض کن می‌خوای یه پروفایل کاربری رو تغییر بدی؛ درخواست PUT می‌فرسته تا اطلاعات قدیمی رو با اطلاعات جدید جایگزین کنه.

نکته مهم:
ـPUT اطلاعاتی که از قبل وجود دارن رو کاملاً جایگزین می‌کنه.


ـ4. PATCH
کاری که انجام میده:
این متد هم مثل PUT برای آپدیت استفاده می‌شه، ولی فرقش اینه که فقط اون بخش از اطلاعات که تغییر کردن رو عوض می‌کنه، نه همه چیز رو.

مثال ساده:
اگه فقط بخوای اسم کاربری رو تغییر بدی، درخواست PATCH می‌فرسته تا فقط همون بخش رو آپدیت کنه و بقیه اطلاعات سر جاش بمونن.


ـ5. DELETE
کاری که انجام میده:
همون‌طور که از اسمش پیداست، این متد برای حذف کردن اطلاعات از سرور استفاده می‌شه.

مثال ساده:
وقتی می‌خوای یه پست یا یه چیزی رو از سرور پاک کنی، درخواست DELETE می‌فرستی.


ـ6. HEAD
کاری که انجام میده:
این متد شبیه GET هست، ولی فقط سرصفحه‌ها (header) رو از سرور می‌گیره، بدون اینکه خود محتوا رو دریافت کنه.

مثال ساده:
اگه بخوایم فقط چک کنیم که یه صفحه وجود داره یا نه، بدون اینکه کل محتوا رو دانلود کنیم، از HEAD استفاده می‌کنیم.


ـ7. OPTIONS
کاری که انجام میده:
این متد از سرور می‌پرسه که چه متدهایی برای یک منبع (resource) خاص در دسترسه. یعنی می‌پرسه: "می‌تونم با این منبع چی‌کار کنم؟"

مثال ساده:
اگه بخوایم بفهمیم چه متدهایی (GET، POST و غیره) برای یه URL خاص پشتیبانی می‌شه، از OPTIONS استفاده می‌کنیم.


ـ8. CONNECT
کاری که انجام میده:
این متد برای ایجاد یه کانال ارتباطی امن (مثل HTTPS) بین کلاینت و سرور استفاده می‌شه.

مثال ساده:
وقتی می‌خوای یه اتصال امن مثل HTTPS راه بندازی، مرورگر از CONNECT استفاده می‌کنه.


ـ9. TRACE
کاری که انجام میده:
این متد برای دیباگ کردن مسیر یه درخواست بین مرورگر و سرور استفاده می‌شه. سرور درخواست رو همون‌طور که دریافت کرده، برمی‌گردونه.

مثال ساده:
اگه بخوایم بررسی کنیم که یه درخواست دقیقاً چه مسیری رو طی کرده تا به سرور برسه، از TRACE استفاده می‌کنیم.

خلاصه و مقایسه ساده متدها:

ـGET: اطلاعات بگیر، چیزی تغییر نده.
ـPOST: اطلاعات بفرست، تغییر بده.
ـPUT: اطلاعات قدیمی رو کامل جایگزین کن.
ـPATCH: فقط اون چیزی که لازمه رو تغییر بده.
ـDELETE: اطلاعات رو حذف کن.
ـHEAD: اطلاعات درباره سرصفحه‌ها بگیر، محتوا رو نگیر.
ـOPTIONS: ببین چه متدهایی مجازه.
ـCONNECT: کانال امن راه بنداز.
ـTRACE: مسیر درخواست رو بررسی کن.
نکات مهم:

ـGET و POST رایج‌ترین متدها هستن.
ـGET و HEAD هیچ‌وقت نباید چیزی رو توی سرور تغییر بدن.
ـPOST و PUT معمولاً برای ارسال یا تغییر اطلاعات استفاده می‌شن.

---
<h2>HTTP STATUS CODES</h2>


  دسته‌بندی اصلیStatus Codes:
<div dir="ltr">
1XX =>اطلاعات غیر قابل تاثیر در پردازش 
 
2XX => موفقیت در درخواست

3XX => Redirect 

4XX => Client Side Error 

5XX => Server Side Error
</div>

وضعیت‌های رایج و مهم:
ـ1. 200 OK - همه‌چی عالیه
این یعنی درخواستت درست بوده و سرور جواب رو داده. اگه دنبال یه صفحه یا منبع خاص بودی و 200 گرفتی، یعنی همه‌چی درسته و صفحه موجوده.

مثال ساده:
وقتی یه صفحه از وب‌سایت رو می‌خوای ببینی، با GET درخواست می‌دی که اون صفحه رو برات بیاره. یا مثلاً وقتی می‌خوای توی یه فرم جستجو کنی، می‌تونی با GET پارامترهای جستجو رو توی URL بفرستی:
example.com/search?query=something

ـ2. 201 Created - ساخته شد
وقتی یه درخواست POST می‌فرستی و 201 می‌گیری، یعنی چیزی توی سرور ساخته شده (مثلاً یه کاربر جدید یا یه فایل آپلود شده).

مثال ساده:
وقتی یه فرم ثبت‌نام رو پر می‌کنی و می‌خوای اطلاعاتت رو بفرستی، POST استفاده می‌شه و اگر 201 بگیری، یعنی ثبت‌نامت موفقیت‌آمیز بوده.

ـ3. 204 No Content - هیچ محتوایی نیست
یعنی درخواستت درست بوده، ولی سرور هیچ محتوایی برای برگردوندن نداره. این وضعیت زمانی میاد که مثلاً یه چیزی رو حذف کردی یا تغییری ایجاد کردی که نیاز نیست سرور جوابی برگردونه.

مثال ساده:
وقتی تست حذف یا تغییر داده انجام می‌دی و 204 گرفتی، یعنی عملیات موفق بوده.

ـ4. 301 Moved Permanently - تغییر مسیر دائمی
سرور می‌گه که صفحه‌ای که دنبالش بودی، به یه URL دیگه منتقل شده. اگه دوباره هم این درخواست رو بفرستی، مرورگر به URL جدید هدایتت می‌کنه.

مثال ساده:
وقتی آدرس یه صفحه تغییر کرده و 301 می‌گیری، مرورگر به طور خودکار به آدرس جدید هدایت می‌شه.

ـ5. 302 Found - تغییر مسیر موقتی
شبیه 301، ولی این یکی موقتیه. یعنی سرور می‌گه الان باید بری به یه URL دیگه، ولی ممکنه در آینده این URL دوباره کار کنه.

مثال ساده:
وقتی صفحه‌ای موقتی جابجا شده و 302 می‌گیری، باید به URL جدید بری، اما این تغییر ممکنه دائم نباشه.
. 

مثال ساده:
وقتی URL یا پارامترهای درخواستت اشتباه هستن و 400 می‌گیری، یعنی باید درخواستت رو اصلاح کنی.

ـ7. 401 Unauthorized - احراز هویت نشد
سرور می‌گه که برای دسترسی به این منبع باید احراز هویت بشی. یعنی بدون ورود به سیستم (login) نمی‌تونی از این صفحه یا منبع استفاده کنی.

مثال ساده:
وقتی نیاز به ورود به حساب کاربری داری و 401 می‌گیری، یعنی باید نام کاربری و رمز عبور صحیح وارد کنی.

ـ8. 403 Forbidden - دسترسی ممنوعه
این یعنی حتی اگه احراز هویت کرده باشی، اجازه دسترسی به این منبع یا صفحه رو نداری. سرور دسترسی رو به دلایلی رد کرده.

مثال ساده:
وقتی حتی با وارد کردن اطلاعات درست هم نمی‌تونی به صفحه‌ای دسترسی پیدا کنی و 403 می‌گیری، یعنی دسترسی به اون منبع ممنوع شده.

ـ9. 404 Not Found - پیدا نشد
یعنی صفحه یا فایلی که دنبالش هستی توی سرور نیست. شاید URL اشتباهه یا منبع حذف شده.

مثال ساده:
وقتی صفحه‌ای که به دنبال اون بودی وجود نداره و 404 می‌گیری، یعنی یا URL اشتباهه یا صفحه حذف شده.

ـ10. 405 Method Not Allowed - متد مجاز نیست
یعنی متدی که استفاده کردی (مثل POST، GET، DELETE) برای این منبع مجاز نیست.

مثال ساده:
وقتی درخواست DELETE برای منبعی که فقط GET پشتیبانی می‌کنه می‌فرستی و 405 می‌گیری، یعنی این متد برای این منبع مناسب نیست.

ـ11. 500 Internal Server Error - خطای داخلی سرور
یعنی سرور یه مشکل داخلی داره و نمی‌تونه درخواستت رو انجام بده. معمولاً وقتی کد سرور خراب باشه یا مشکلی در پردازش درخواست پیش بیاد، این کد برمی‌گرده.

مثال ساده:
وقتی درخواستت به‌درستی پردازش نمی‌شه و 500 می‌گیری، یعنی یه مشکل داخلی در سرور وجود داره.


ـ12. 502 Bad Gateway - درگاه نامناسب
یعنی سرور یه پاسخ نامناسب از یه سرور دیگه (که مثل یه واسطه عمل می‌کنه) دریافت کرده.

مثال ساده:
وقتی چندین سرور درگیر هستن و یکی از این سرورها به درستی کار نمی‌کنه و 502 می‌گیری، یعنی مشکلی در ارتباط بین سرورها وجود داره.
ـ13. 503 Service Unavailable - سرویس در دسترس نیست
یعنی سرور به‌خاطر شلوغی یا مشکلات دیگه نمی‌تونه درخواستت رو انجام بده. شاید هم سرور داره آپدیت می‌شه یا موقتاً خاموشه.

مثال ساده:
وقتی سرور به دلایل مختلف نمی‌تونه درخواستت رو انجام بده و 503 می‌گیری، یعنی ممکنه سرور موقتاً در دسترس نباشه یا تحت فشار باشه.

نکات مهم:

کدهای 4xx رو برای پیدا کردن نقاط ضعف دسترسی (authorization) و ورودی‌های اشتباه تست کن.
کدهای 5xx می‌تونن سرنخ‌های خوبی از مشکلات داخلی سرور و احتمالاً آسیب‌پذیری‌ها بدن.
ریدایرکت‌ها (3xx) رو بررسی کن تا مطمئن شی که درست هدایت می‌شی یا ببینی آیا می‌تونی اون‌ها رو دور بزنی.

---
<h2>SOP (Same Origin Policy)</h2>


 یک قاعده امنیتی در مرورگرهاست که به این ترتیب عمل می‌کند: اگر وب‌سایت A بخواهد به وب‌سایت B درخواست ارسال کند، مرورگر تنها می‌تواند داده‌های وب‌سایت B را دریافت کند، اما اجازه نمی‌دهد که این داده‌ها به وب‌سایت A ارسال یا نمایش داده شوند. این قاعده برای جلوگیری از مشکلات امنیتی مثل دسترسی غیرمجاز به داده‌های دیگر سایت‌ها طراحی شده است.

ـOrigin?
ـOrigin ترکیبی از سه بخش اصلی است:
ـport - protocol - host

پروتکل (مثل http یا https)
دامنه (مثل example.com)
پورت (مثل 80 یا 443)

مثال‌های ساده:

ـSame Origin:

https://example.com:443/index.php

https://example.com/dashboard

این دو URL Same Origin هستند زیرا پروتکل، دامنه و پورت یکی است.

ـCross Origin به خاطر دامنه متفاوت:
```domain
https://target.com/index.php
https://example.com/home
```
این دو URL Cross Origin هستند چون دامنه‌ها متفاوت است.

ـCross Origin به خاطر پروتکل متفاوت:
```domain
http://example.com/home
https://example.com/home
```
این دو URL Cross Origin هستند چون پروتکل‌ها (http و https) متفاوت است.

ـCross Origin به خاطر پورت متفاوت:
```domain
http://example.com:8080
http://example.com
```

این دو URL Cross Origin هستند چون پورت‌ها متفاوت است.

ـCross Origin به خاطر دامنه متفاوت:
```domain
https://www.example.com/home/index.php
https://example.com/dashboard
```
این دو URL Cross Origin هستند چون دامنه‌ها متفاوت است.

چطور SOP عمل می‌کند؟
فرض کن هکر دو تب باز کرده است:

یکی به سایت hacker.com مربوط می‌شود.
دیگری به سایت bank.com مربوط می‌شود.
اگر SOP وجود نداشت، هکر می‌توانست از hacker.com درخواست‌هایی به bank.com ارسال کند و اطلاعات حساس کاربر را بخواند. اما SOP مانع این کار می‌شود. یعنی درخواست از hacker.com به bank.com ارسال می‌شود، اما مرورگر داده‌های برگشتی از bank.com را به hacker.com نمی‌دهد.

محدودیت‌های SOP:

تصاویر: SOP روی تصاویر اعمال نمی‌شود. می‌توان از هر سایتی تصویری را بارگیری کرد و در سایت خود نمایش داد.

فایل‌های جاوااسکریپت: SOP روی فایل‌های جاوااسکریپت نیز اعمال نمی‌شود. بنابراین، فایل‌های جاوااسکریپت موجود در یک سایت می‌توانند توسط دیگر سایت‌ها خوانده شوند که ممکن است به آسیب‌پذیری‌های امنیتی منجر شود.

نکته مهم: SOP فقط برای درخواست‌های HTTP و HTTPS کار می‌کند. اگر سایت از پروتکل‌های دیگر مانند WebSocket استفاده کند، SOP به آن اعمال نمی‌شود.

---
<h2>Web Structure</h2>


فایل‌های استاتیک (Static Files)

فایل‌های استاتیک همون فایل‌های ساده‌ای هستن که توی سرور ذخیره می‌شن و وقتی کاربر (کلاینت) درخواستشون رو از سرور می‌کنه، سرور بدون هیچ تغییری اون‌ها رو مستقیم به کاربر می‌فرسته. مثلا وقتی کاربر می‌خواد یه فایل index.html رو باز کنه، سرور همون فایل رو همون‌طور که هست به مرورگر کاربر ارسال می‌کنه. فایل‌هایی مثل .html، .css، .js، یا تصاویر .png و .jpg جزو فایل‌های استاتیک حساب می‌شن.

این فایل‌ها رو سرور اجرا نمی‌کنه، بلکه مرورگر کاربر اونا رو دریافت می‌کنه و خودش اجراشون می‌کنه. به خاطر همین بهشون "استاتیک" یا "ثابت" می‌گن، چون سرور هیچ تغییری توی محتوای این فایل‌ها نمی‌ده.

فایل‌های داینامیک (Dynamic Files)

فایل‌های داینامیک با فایل‌های استاتیک فرق دارن. وقتی یه کاربر درخواست یه فایل داینامیک مثل index.php رو از سرور می‌کنه، سرور اول اون فایل رو مستقیماً برای کاربر نمی‌فرسته. در عوض، سرور اون فایل رو به یه برنامه (مثل مفسر PHP) می‌فرسته تا پردازش بشه و نتیجه‌ای که از اجرای اون فایل به دست میاد برای کاربر فرستاده می‌شه.

این یعنی محتواشون همیشه ثابت نیست و بسته به درخواست کاربر می‌تونه تغییر کنه. به همین دلیل به این نوع فایل‌ها "داینامیک" یا "پویا" می‌گن، چون توی سرور قبل از فرستادن برای کاربر پردازش می‌شن.

---
<h2>Spidering & Crawling </h2>

ـCrawling

تو دنیای وب و پنتست، Crawling یعنی جست‌وجوی خودکار صفحات یه سایت توسط یه برنامه یا ابزار. مثل این می‌مونه که وقتی وارد یه سایت می‌شی، به جای اینکه خودت تک‌تک صفحات رو باز کنی، یه ربات بهت کمک کنه که همه لینک‌ها و صفحات اون سایت رو پیدا کنی و بررسی کنی. این ربات همه لینک‌هایی که توی سایت وجود دارن رو دنبال می‌کنه و اطلاعات هر صفحه رو برای تو جمع می‌کنه.

برای مثال، یه ابزار مثل Burp Suite می‌تونه بره و همه لینک‌ها، فرم‌ها، و حتی زیرمجموعه‌های دیگه یه سایت رو خودش به‌صورت خودکار کشف کنه و بهت نشون بده.

ـSpidering

در واقع Spidering یه جورایی شبیه Crawling هست ولی یه قدم جلوتره. وقتی ابزارهای Spidering استفاده می‌کنی، اونا نه فقط لینک‌های داخلی سایت رو دنبال می‌کنن، بلکه هر چیزی که مربوط به دامنه یا زیر دامنه سایت باشه رو هم پیدا می‌کنن. یعنی مثل یه عنکبوت که تار می‌تنه، این ابزارها همه بخش‌های ممکن از یه سایت رو جستجو می‌کنن تا هیچ نقطه‌ای رو جا نذارن.

این ابزارها تلاش می‌کنن که هر بخشی از سایت (چه لینک‌های داخلی، چه لینک‌های خارجی) رو کشف کنن و ازش استفاده کنن تا هر گوشه از سایت رو ببینی و بهت کمک کنه که نقاط ضعف امنیتی رو راحت‌تر پیدا کنی.

جمع‌بندی به زبان ساده:
ـCrawling:
 جستجوی لینک‌ها و صفحات داخل خود سایت، بدون اینکه وارد دنیای بیرون سایت بشه.
ـSpidering:
 جستجوی کامل‌تر که حتی دامنه‌های خارجی و بخش‌های دیگه‌ای که به سایت وصل هستن رو هم بررسی می‌کنه.
این دوتا خیلی به درد پنتسترها می‌خوره، چون کمک می‌کنه که کل ساختار سایت رو بشناسی و نقاط ضعفش رو پیدا کنی.

---
<h1>Javascript Prerequisite</h1>



ـ1. DOM (Document Object Model)

در واقع DOM یه API هست که به کمکش جاوا اسکریپت (JS) می‌تونه با HTML یا XML یه صفحه ارتباط برقرار کنه. به زبون ساده، DOM تمام تگ‌های HTML رو به صورت object در جاوا اسکریپت می‌شناسه و به JS اجازه میده که باهاشون کار کنه. هر چیزی که توی HTML داریم، مثل تگ‌ها، توی جاوا اسکریپت به عنوان element شناخته میشه و JS می‌تونه از طریق DOM بهشون دسترسی پیدا کنه.

مثال:
وقتی یه تگ HTML داریم مثل <p>Hello</p>، جاوا اسکریپت از طریق DOM می‌تونه این تگ رو ببینه و باهاش تعامل کنه. مثلاً می‌تونه محتوای تگ رو تغییر بده.


ـ2. CRP (Critical Rendering Path)
یعنی راهی که مرورگر طی می‌کنه تا یه صفحه رو رندر کنه. هر مرورگر یه مسیر مشخص داره تا اولویت‌بندی کنه که چه قسمت‌هایی از صفحه زودتر نشون داده بشن. این مسیر به کمک DOM و اطلاعاتی که از HTML داره تعیین میشه. به‌طور خلاصه، CRP تصمیم می‌گیره کدوم بخش‌های صفحه اول از همه به کاربر نمایش داده بشن.


ـ3. DOM Source و DOM Sink

ـDOM Source:
 جایی که اطلاعات کاربر ذخیره میشه. یعنی وقتی کاربر اطلاعاتی رو توی یه فرم وارد می‌کنه، این اطلاعات توی DOM Source ذخیره میشه.

مثال‌هایی از DOM Source:
document.url
location.hash
xhr.responseText

ـDOM Sink:
 جاییه که اطلاعات کاربر اجرا میشه. مثلاً وقتی یه اسکریپت به مرورگر میگه چیزی رو توی صفحه نمایش بده یا یه چیزی رو تغییر بده، از DOM Sink استفاده میشه.

مثال‌هایی از DOM Sink:
document.write()
innerHTML
postMessage


ـ4. BOM (Browser Object Model)
ـBOM همون مدلیه که مرورگر برای کار با جاوا اسکریپت ارائه میده. برخلاف DOM که فقط با ساختار HTML کار می‌کنه، BOM به جاوا اسکریپت اجازه میده که با مرورگر تعامل داشته باشه. یعنی اطلاعاتی مثل نسخه مرورگر، اندازه پنجره، و حتی اجرای کارهایی مثل هشدار دادن به کاربر رو مدیریت کنه.

می‌تونه شامل مواردی مثل:
نسخه مرورگر
عرض و ارتفاع پنجره مرورگر

متدهای مهم مثل:
alert() (برای نشون دادن پیام به کاربر)
confirm() (برای گرفتن تایید از کاربر)
prompt() (برای گرفتن ورودی از کاربر)
setInterval() و setTimeout() (برای اجرای کدها بعد از یه مدت زمان خاص)


نکته:
ـwindow.document == document این عبارت یعنی document (که همون DOM هست) بخشی از window (که همون BOM هست) محسوب میشه.


خلاصه
ـDOM: جاوا اسکریپت رو به HTML وصل می‌کنه.
ـCRP: مسیر رندر شدن صفحه توی مرورگر رو تعیین می‌کنه.
ـDOM Source و Sink: جایی که اطلاعات کاربر ذخیره و اجرا میشه.
ـBOM: به جاوا اسکریپت اجازه میده با مرورگر تعامل داشته باشه.

---
ـAJAX or XHR(XMLHttpRequest)

یه راه برای ارتباط با سرور بدون لود کردن دوباره صفحه هست. یعنی می‌تونی اطلاعاتی از سرور بگیری یا به سرور بفرستی، بدون اینکه کل صفحه رفرش بشه. این کار باعث میشه تجربه کاربری بهتر بشه و تعامل با سرور سریع‌تر اتفاق بیفته.

چطوری کار می‌کنه؟
فرض کن تو یه سایتی هستی و می‌خوای اطلاعاتی از سرور بگیری، مثلاً یه سری داده مثل توکن یا نوشته مخفی. به جای اینکه کل صفحه رفرش بشه، می‌تونی از Ajax استفاده کنی تا فقط همون اطلاعاتی که می‌خوای، از سرور بگیری و تو صفحه‌ات نشون بدی. این کار خیلی سریع‌تره و صفحه رو هم به هم نمی‌ریزه.

حالا بریم سراغ یه مثال از یه حمله ساده که نشون میده چطور از این قابلیت میشه استفاده کرد.

سناریوی حمله با استفاده از XHR:
فرض کن سایتی داری که توش یه صفحه مخفی به اسم secret.html هست. توی این صفحه یه توکن ذخیره شده، مثلاً برای اعتبارسنجی یا هر چیز دیگه‌ای:


```html
https://target.com/secret.html:
```
```html
<!DOCTYPE html>
<html>
<body>
    <h2>Secret Text</h2>
    <p id="token"> kjglkfdglkfdglkfdglkfdg </p> <!-- there is the token -->
</body>
</html>
```
کاربر معمولی شاید نتونه به سادگی به این توکن دسترسی پیدا کنه. اما با استفاده از یه اسکریپت ساده، یه هکر می‌تونه این توکن رو بدزده. برای این کار، هکر یه صفحه مثل hijacktoken.html درست می‌کنه و یه دکمه توی صفحه قرار میده. وقتی کاربر روی دکمه کلیک کنه، درخواست XHR به صفحه secret.html فرستاده میشه و توکن دزدیده میشه:

```html
https://target.com/hijacktoken.html:
```
```html
<!DOCTYPE html>
<html>
<body>
    <button id="btn">click</button><br>
    <p>token : </p>
    <div id="tok"></div>

<script>
    var btn = document.getElementById("btn");
    btn.addEventListener("click",()=>{
        // XHR request to server to get secret.htm
        const xhr = new XMLHttpRequest();
        xhr.open("GET","https://target.com/secret.html",true);
        xhr.responseType = "document";
        xhr.send();

        // When the request is successful, show the token on the page
        xhr.onreadystatechange = ()=>{
            if(xhr.readyState == 4 && xhr.status == 200){
                var inject_in_site = document.getElementById("tok");
                inject_in_site.innerHTML = xhr.response.getElementById("token").textContent;
            }
        }
    });
</script>
</body>
</html>
```
توضیح کد بالا:
توی این صفحه یه دکمه داریم که وقتی روش کلیک بشه، یه درخواست XHR به صفحه secret.html ارسال میشه.
مرورگر این درخواست رو به سرور می‌فرسته تا محتوای صفحه رو بگیره، و چون نوع پاسخ رو به صورت document تعریف کردیم، کل محتوای HTML رو به عنوان پاسخ می‌گیره.
وقتی پاسخ از سرور برگشت، هکر توی کد جاوااسکریپت خودش اون توکن مخفی رو از DOM صفحه می‌خونه و توی صفحه خودش نمایش میده.

از دید یه هکر:
این یه نوع حمله CSRF (Cross-Site Request Forgery) هست که به کمک XHR انجام میشه. یعنی هکر از یه سایت دیگه به سایت هدف درخواست می‌فرسته و مرورگر به خاطر وجود SOP (Same Origin Policy) نمی‌ذاره اطلاعات حساس رو به دست بیاره. اما با روش‌های مختلف (مثل نقص در تنظیمات امنیتی) ممکنه همچین حمله‌ای موفق بشه.
توی این نوع حملات، هکر سعی می‌کنه از کاربر بخواد که به سایت مخربش بره و بعد با استفاده از درخواست‌های XHR، داده‌های مهم رو از سایت هدف بدزده.

نتیجه‌گیری:
درخواست‌های XHR یا همون Ajax خیلی توی برنامه‌های وب رایجن و کمک می‌کنن که داده‌ها سریع و بدون رفرش شدن صفحه رد و بدل بشن. اما همین قابلیت اگه درست مدیریت نشه، می‌تونه نقطه‌ضعف‌هایی برای هکرها فراهم کنه تا داده‌های حساس رو بدزدن.

---
<h2>CORS (Cross-Origin Resource Sharing)</h2>


در واقع CORS یه راه‌حل امنیتی برای اینه که مرورگرها بفهمن کدوم Originها اجازه دارن از سرورهای مختلف(Cross-Origin) اطلاعات بگیرن. توی حالت عادی، مرورگرها به دلیل قوانین امنیتی، اجازه نمی‌دن سایت‌ها به اطلاعات سایت‌های دیگه دسترسی داشته باشن، مگر اینکه این دسترسی‌ها به صورت واضح توی هدرهای سرور مشخص شده باشه. CORS میاد مشخص می‌کنه کدوم سایت‌ها اجازه دارن از سرور درخواست بزنن و اطلاعات بگیرن.
برای فهم عمیق تر دو مثال میزنم: 
```domain
A - https://api.target.com/user
B - https://target.com/dashboard
```
همانطور که میدونیم دو endpoint بالا یعنی A و B هر دو Cross-Origin هستند و طبق SOP نباید بتواند origin B وقتی به A درخواست میزند و response را دریافت میکند بتواند اطلاعات را بگیرد ولی این عمل به واسطه ی CORS در سرور set شده است.
CORS Important Header in HTTP Request:
```http
Origin: domain.tld
```
CORS Important Headers in HTTP Response:
```http
ACCESS-CONTROL-ALLOW-ORIGIN: domain.tld
ACCESS-CONTROL-ALLOW-CREDENTIAL: true
ACCESS-CONTROL-ALLOW-METHODS:
ACCESS-CONTROL-REQUEST-HEADER:
```

دو نوع درخواست اصلی توی CORS وجود داره:

ـSimple Request :
 این نوع درخواست نیازی به بررسی اولیه (Preflight) نداره، چون هیچ هدر عجیبی توی درخواست فرستاده نمی‌شه. برای مثال:

متدهای مجاز: GET, POST, HEAD
هدرهای مجاز: Accept, Accept-Language, Content-Type
اگه از هدرهای اضافی مثل CSRF-Token یا JWT استفاده نشه، درخواست توی این دسته قرار می‌گیره.

ـPreflight Request : 
این درخواست قبل از درخواست اصلی فرستاده می‌شه تا سرور تأیید کنه که درخواست اجازه داره اجرا بشه. معمولاً برای درخواست‌هایی که هدرهای خاص دارن یا از متدهایی مثل PUT و OPTION استفاده می‌کنن، این نوع درخواست‌ها لازمه.

سناریوی یک حمله با استفاده از CORS:
فرض کن ما دو دامنه داریم:

```http
A: attacker.tld
B: target.tld
```
سرور B به صورت اشتباهی پیکربندی شده و اجازه میده دامنه‌های دیگه، مثل A، ازش درخواست بزنن. مثلاً وقتی از دامنه A یه درخواست به B فرستاده بشه، سرور B توی هدرهای پاسخ خودش به شکل زیر عمل می‌کنه:

درخواست ارسال شده:
```http
Origin: attacker.tld
```
پاسخ سرور B:
```http
Access-Control-Allow-Origin: attacker.tld
Access-Control-Allow-Credentials: true
```
این یعنی سرور B به درخواست‌های دامنه A اجازه میده و حتی کوکی‌ها و اطلاعات حساس رو هم با درخواست می‌فرسته. اینجا CORS به اشتباه پیکربندی شده و امکان داره هکر از این ضعف استفاده کنه و اطلاعاتی مثل توکن یا session کاربر رو بدزده.

مثالی از پیکربندی درست و نادرست CORS:
فرض کن توی مرورگر درخواست زیر رو داری:
```http
Origin: test.com
```
اگه سرور اینطوری پاسخ بده:

```http
Access-Control-Allow-Origin: test.com
Access-Control-Allow-Credentials: true
```
این یعنی سرور به سایت test.com اجازه داده تا بهش دسترسی داشته باشه و اطلاعات حساس مثل کوکی‌ها رو هم می‌فرسته.

ولی اگه اینطوری باشه:

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```
مرورگر خودش جلوی فرستادن کوکی‌ها رو می‌گیره، چون نباید وقتی هدر Allow-Origin برابر با * هست، کوکی‌ها رو بفرسته. به عبارت دیگه، وقتی Credentials برابر با true باشه، Allow-Origin نباید * باشه.

آسیب‌پذیری‌های ناشی از CORS Misconfiguration:
اگه CORS درست تنظیم نشه، می‌تونه خیلی خطرناک باشه. هکر می‌تونه اطلاعات حساسی مثل سشن‌ها، API keyها، و حتی کوکی‌ها رو بدزده. برای اینکه بفهمیم سرور آسیب‌پذیر هست یا نه، باید هدرهای Access-Control-Allow-Origin و Access-Control-Allow-Credentials رو بررسی کنیم. هکرها با تغییر این هدرها و تست کردن دوباره، می‌تونن بفهمن که سرور درست تنظیم شده یا نه.

نتیجه‌گیری:
در اصل CORS یه راه مهم برای کنترل دسترسی بین سایت‌هاست. اگه درست پیکربندی نشه، می‌تونه باعث بشه اطلاعات حساس کاربران به دست هکرها بیفته. همیشه باید به هدرهای Access-Control-Allow-Origin و Access-Control-Allow-Credentials دقت کنیم تا از امنیت سرور مطمئن بشیم.

</div>

